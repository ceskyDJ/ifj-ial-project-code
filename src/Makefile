# Makefile
#
# IFJ and IAL project (IFJ21 compiler)
# Team: 128 (variant II)
#
# Author: Martin Havlík (xhavli56)
# Author: Michal Šmahel (xsmahe01)
# Help: https://devhints.io/makefile
# Inspired by: https://www.throwtheswitch.org/build/make

# Used variables:
# $< ... first dependency
# $^ ... all dependencies
# $@ ... target

BINARY_NAME=ifj21_compiler
DOC_NAME=main

# Project sources
SRC_P=.
# Unit test sources
TEST_P=../test/unit
# Directories with build data
BIN_P=../build/bin
DEP_P=../build/deps
OBJ_P=../build/objs
RES_P=../build/results
RUN_P=../build/runners
# Unity test framework
UNITY_P=../unity

# Test statistics
PASSED_TESTS = `grep -s PASS $(RES_P)/*.txt | sed 's|$(RES_P)/||g' | sed 's/.txt//g' | sed 's|$(TEST_P)/||g'`
FAILED_TESTS = `grep -s FAIL $(RES_P)/*.txt | sed 's|$(RES_P)/||g' | sed 's/.txt//g' | sed 's|$(TEST_P)/||g'`
IGNORED_TESTS = `grep -s IGNORE $(RES_P)/*.txt | sed 's|$(RES_P)/||g' | sed 's/.txt//g' | sed 's|$(TEST_P)/||g'`

# Compiler configs
CC=gcc
CFLAGS=-std=c11 -g -pedantic -Wall -Wextra

# Get a list of all source files (ex.: SRC_P/main.c SRC_P/symtable.c)
SRC_FILES=$(wildcard $(SRC_P)/*.c)
# Transform the list of source files into a list of modules
# It's done by substitution - every *.c file creates one object one (*.o),
# so we can just change extension and path and we're done
MODULES=$(patsubst $(SRC_P)/%.c, $(OBJ_P)/%.o, $(SRC_FILES))
# Get a list of all unit test source files (similar to SRC_FILES)
TEST_FILES=$(wildcard $(TEST_P)/*.c)
# Transform the list of unit tests' source files into a list of test output files (similar to MODULES)
TEST_OUTPUTS=$(patsubst $(TEST_P)/%.c, $(RES_P)/%.txt, $(TEST_FILES))

# `make` only compiles main binary
all: build

# Template for compiling modules
# This is used for rules generated by `dep` rule
$(OBJ_P)/%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Link modules into final binary
build: $(MODULES)
	$(CC) $(CFLAGS) $^ -o $(BIN_P)/$(BINARY_NAME)

#######################################
# Generate module dependencies
dep:
	$(CC) -MM *.c >$(DEP_P)/dep.list

-include $(DEP_P)/dep.list
#######################################

#########################################################TESTS##########################################################
# Prepare and run tests
test: $(TEST_OUTPUTS)
	@echo -e "----------------------\n\tIGNORE\n----------------------"
	@echo "$(IGNORED_TESTS)"
	@echo -e "----------------------\n\tPASSED\n----------------------"
	@echo "$(PASSED_TESTS)"
	@echo -e "----------------------\n\tFAILED\n----------------------"
	@echo "$(FAILED_TESTS)"

# Generate test results
$(RES_P)/test_%.txt: $(BIN_P)/test_%
	-./$< >$@ 2>&1

# Create tests' binaries
$(BIN_P)/test_%: $(OBJ_P)/unity.o $(OBJ_P)/unity_memory.o $(OBJ_P)/test_%_runner.o $(OBJ_P)/test_%.o $(OBJ_P)/%.o
	$(CC) $^ -o $@

# Compile unit tests' modules
$(OBJ_P)/test_%.o: $(TEST_P)/test_%.c
	$(CC) $(CFLAGS) -c $< -o $@ -DTEST

# Compile unit test runners' modules
$(OBJ_P)/%_runner.o: $(RUN_P)/%_runner.c
	$(CC) $(CFLAGS) -c $< -o $@ -DTEST

# Generate unit test runners' source code
$(RUN_P)/%_runner.c: $(TEST_P)/%.c
	ruby $(UNITY_P)/auto/generate_test_runner.rb $< $@

# Compile Unity framework's main module
$(OBJ_P)/unity.o: $(UNITY_P)/src/unity.c $(UNITY_P)/src/unity.h
	$(CC) $(CFLAGS) -c $< -o $@ -DUNITY_INCLUDE_CONFIG_H

# Compile Unity framework's memory add-on module
$(OBJ_P)/unity_memory.o: $(UNITY_P)/extras/unity_memory.c $(UNITY_P)/extras/unity_memory.h
	$(CC) $(CFLAGS) -c $< -o $@

# Don't delete results of explicit rules at the end of rule processing
.PRECIOUS: $(RUN_P)/%_runner.c
.PRECIOUS: $(OBJ_P)/%_runner.o
.PRECIOUS: $(OBJ_P)/test_%.o
.PRECIOUS: $(BIN_P)/test_%
.PRECIOUS: $(RES_P)test_%.txt
########################################################################################################################

# Compile documentation (from its Git repository)
# BibTeX may not be needed
doc:
	git clone git@github.com:ceskyDJ/ifj-ial-project-docs.git
	cd ifj-ial-project-docs; grep -q "\citation" $(DOC_NAME).tex && pdflatex $(DOC_NAME).tex || true
	cd ifj-ial-project-docs; grep -q "\citation" $(DOC_NAME).tex && bibtex $(DOC_NAME).aux || true
	cd ifj-ial-project-docs; pdflatex $(DOC_NAME).tex
	cd ifj-ial-project-docs; pdflatex $(DOC_NAME).tex
	mv ifj-ial-project-docs/$(DOC_NAME).pdf ../tmp/dokumentace.pdf
	rm -rf ifj-ial-project-docs

# Create final archive
archive: make_tmp doc copy_src copy_special copy_makefile
	cd ../tmp; tar -czf ../xsmahe01.tar.gz *
	rm -rf ../tmp

# Copy source files into tmp folder (for creating archive)
# *.h files could missing
copy_src:
	cp -r *.c ../tmp/
	ls *.h >/dev/null 2>&1 && cp -r *.h ../tmp/ || true

# Copy special files (required by assignment) into tmp folder
# `rozsireni` could missing
copy_special:
	cp ../rozdeleni ../tmp/
	[ -f ../rozsireni ] && cp ../rozsireni ../tmp/ || true

# Copy Makefile into tmp folder with path conversion (development paths to production ones)
copy_makefile:
	cp Makefile ../tmp/
	sed -i 's/..\/bin/./' ../tmp/Makefile

# Create tmp folder where the final project structure will be prepared
make_tmp:
	mkdir ../tmp

# Define virtual files and cleaning stuff
.PHONY: clean doc all archive copy_src copy_special make_tmp build dep copy_makefile test
clean:
	rm -f *.o *.c~ *.h~

cleanall: clean
	rm -f $(BIN_P)/* $(DEP_P)/* $(OBJ_P)/* $(RES_P)/* $(RUN_P)/* ../xsmahe01.tar.gz
